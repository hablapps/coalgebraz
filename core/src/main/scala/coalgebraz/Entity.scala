package coalgebraz

import Function.const

import scalaz._, Scalaz._

trait EntityCore extends EntityNextDsl
    with EntityWrapDsl
    with ToObservableOps
    with ToMappableOps
    with ToEntityOps {

  def entity[I, O, B, X](
      pi1: X => B,
      pi2: X => I => (List[O], Option[X])): Entity[I, O, B, X] = { x =>
    EntityF(pi1(x), pi2(x))
  }

  def next[I, O, X](f: X => I => (List[O], Option[X])): Entity[I, O, X, X] =
    entity(identity, f)

  def next2[I, O, B, X: Observable[B, ?]](
      f: X => I => (List[O], Option[X])): Entity[I, O, B, X] =
    entity(_.observe, f)

  def always[I, O, B, X](b: B): Entity[I, O, B, X] =
    entity(const(b), x => _ => x)

  def til[I, O, B, X](b: B, f: I => Boolean): Entity[I, O, B, X] =
    entity(const(b), x => i => if (f(i)) halt else x)

  def blocked[O, B, X](to: X -> B): Entity[Void, O, B, X] =
    entity(to.to(_), _ => _ => ??? /* does never happen */)

  def once[I, O, B, X](b: B): Entity[I, O, B, X] =
    entity(const(b), _ => _ => halt)

  def until[I, O, B, X](
      f: I => Boolean)(
      co: Entity[I, O, B, X]): Entity[I, O, B, X] =
    untilOut[I, O, B, X](f)(co)

  def untilOut[I, O, B, X](
      f: I => Boolean,
      g: B => I => List[O] = (_: B) => (_: I) => List.empty[O])(
      co: Entity[I, O, B, X]): Entity[I, O, B, X] = { x =>
    val EntityF(obs, nxt) = co(x)
    EntityF(obs, i => if(f(i)) (g(obs)(i), None) else nxt(i))
  }

  def untilAndNext[I, O, B, X](
      f: I => Boolean)(
      co1: Entity[I, O, B, X],
      co2: Entity[I, O, B, X]): Entity[I, O, B, (X, Boolean)] =
    xAndNext[I, O, B, X](nxt1 => nxt2 => i =>
      f(i).fold(g(nxt2(i), true), g(nxt1(i), false)))(co1, co2)

  def andthen[I, O, B, X](
      co1: Entity[I, O, B, X],
      co2: Entity[I, O, B, X]): Entity[I, O, B, (X, Boolean)] = {
    xAndNext[I, O, B, X](nxt1 => nxt2 => i => {
      val t@(os, ox) = nxt1(i)
      ox.fold(g(nxt2(i), true).swap.map(os ++ _).swap)(_ => g(t, false))
    })(co1, co2)
  }

  def interleave[I, O, B, X](
      co1: Entity[I, O, B, X],
      co2: Entity[I, O, B, X]): Entity[I, O, B, (X, Boolean)] = { case (x, s) =>
    lazy val EntityF(obs1, nxt1) = co1(x)
    lazy val EntityF(obs2, nxt2) = co2(x)
    s.fold(
      EntityF(obs2, i => g(nxt1(i), false)),
      EntityF(obs1, i => g(nxt2(i), true)))
  }

  // XXX: don't know why the next invocation can't be resolved:
  // `Functor[(List[O], Option[?])]`
  // As a consequence, I have to manually compose functors.
  private def g[I, O, X](
      t: (List[O], Option[X]),
      b: Boolean): (List[O], Option[(X, Boolean)]) =
    Functor[Tuple2[List[O], ?]].compose[Option].apply(t)((_, b))

  private def xAndNext[I, O, B, X](
      f: Next[I, O, X] => Next[I, O, X] => Next[I, O, (X, Boolean)])(
      co1: Entity[I, O, B, X],
      co2: Entity[I, O, B, X]): Entity[I, O, B, (X, Boolean)] = { case (x, s) =>
    if (s) {
      val EntityF(obs2, nxt2) = co2(x)
      EntityF(obs2, i => g(nxt2(i), true))
    } else {
      lazy val EntityF(obs1, nxt1) = co1(x)
      lazy val EntityF(_, nxt2) = co2(x)
      EntityF(obs1, f(nxt1)(nxt2))
    }
  }

  def block[I, O, B, X](co: Entity[I, O, B, X]): Entity[(I, Void), O, B, X] =
    in(co)(_ => _ => ???)

  // XXX: Is `unblock` even possible?
  // def unblock[I, O, B, X](
  //   nxt: I => (List[O], Option[X]))(
  //   co: Entity[(I, Void), O, B, X]): Entity[I, O, B, X]

  def stop[I, O, B, X](co: Entity[I, O, B, X]): Entity[I, O, B, X] =
    until(const[Boolean, I](true))(co)

  def stopOut[I, O, B, X](f: B => I => List[O])(co: Entity[I, O, B, X]) =
    untilOut(const(true), f)(co)

  def carrier[I, O, B, X, X2](
      co: Entity[I, O, B, X])(implicit
      iso: X <-> X2): Entity[I, O, B, X2] = { x2 =>
    val EntityF(obs, nxt) = co(iso.from(x2))
    EntityF(obs, i => nxt(i).map(_ map iso.to))
  }

  def observe[I, O, B, X, B2](
      co: Entity[I, O, B, X])(implicit
      ev0: B -> B2): Entity[I, O, B2, X] = { x =>
    val EntityF(obs, nxt) = co(x)
    EntityF(ev0.to(obs), nxt)
  }

  // Feeds a coalgebra with a list of inputs and returns the final state (if
  // any) along with the list of outputs that were generated by the system.
  def feed[I, O, B, X](
      co: Entity[I, O, B, X],
      in: List[I],
      x: X): (List[O], Option[X]) = in match {
    case Nil => x
    case i::is => {
      val EntityF(_, nxt) = co(x)
      nxt(i) match {
        case (os, Some(x2)) => feed(co, is, x2).mapElements(_1 = os ++ _)
        case (os, None) => halt ~> (os: _*)
      }
    }
  }

  // Adapts a system to map input broader events into smaller ones, given a
  // mapper function.
  def in[I, O, B, X, I2](
      co: Entity[I, O, B, X])(implicit
      r: Router[B, I2, I]): Entity[I2, O, B, X] = { x =>
    val EntityF(obs, nxt) = co(x)
    EntityF(obs, i => feed(co, r(obs)(i), x))
  }

  // Adapts a system to map output smaller events into broader ones, given a
  // mapper function.
  def out[I, O, B, X, O2](
      co: Entity[I, O, B, X])(implicit
      r: Router[B, O, O2]): Entity[I, O2, B, X] = { x =>
    val EntityF(obs, nxt) = co(x)
    EntityF(obs, i => nxt(i).swap.map(_ flatMap r(obs)).swap)
  }

  def back[I, O, B, X](
      co: Entity[I, O, B, X])(implicit
      r: B => O => List[I]): Entity[I, O, B, X] = { x =>
    type Out = (List[O], Option[X])

    def g(acc: List[O], q: List[O], s: X, nxt: I => Out): Out = q match {
      case Nil => (acc, Option(s))
      case h::t => {
        r(co(s).observe)(h) match {
          case Nil => g(acc :+ h, t, s, nxt)
          case is => {
            val (os, ox) = feed(co, is, s)
            ox.fold((acc ++ q, Option.empty[X]))(g(acc :+ h, t ++ os, _, nxt))
          }
        }
      }
    }

    val EntityF(obs, nxt) = co(x)
    EntityF(obs, i => nxt(i) match {
      case res@(_, None) => res
      case (os, Some(x2)) => g(List.empty, os, x2, nxt)
    })
  }

  def inside[I, O, B, X](
      co: Entity[I, O, B, X])(
      f: B => List[O]): Entity[I, O, B, X] = { x =>
    val EntityF(obs, nxt) = co(x)
    EntityF(obs, i => nxt(i) match {
      case res@(_, None) => res
      case (os, Some(x2)) => {
        val EntityF(b, _) = co(x2)
        (os ++ f(b), Option(x2))
      }
    })
  }

  type IndexedEntity2[I, O, F[_, _], B, X, N] =
    Entity[IndexIn[I, B, N], IndexOut[O, B, N], F[N, B], F[N, X]]

  def index2[I, O, F[_, _], B, X, N](
      co: Entity[I, O, B, X])(implicit
      ev0: Observable[B, X],
      ev1: Functor[F[N, ?]],
      ev2: Mappable[F],
      ev3: To[B, X]): IndexedEntity2[I, O, F, B, X, N] = { xs =>
    EntityF(xs.map(co(_).observe), {
      case Attach((n, b)) => (xs + (n, ev3.to(b))) ~> Attached((n, b))
      case Detach(n) => (xs contains n).fold(
        (xs - n) ~> Detached(n),
        xs ~> UnknownIndex(n))
      case WrapIn((n, i)) => {
        type Out = (List[IndexOut[O, B, N]], Option[F[N, X]])
        (xs get n).fold[Out](xs ~> UnknownIndex(n)) { x =>
          co(x).next(i).bimap(_.map(o => WrapOut((n, o))), _.map(xs + (n, _)))
        }
      }
    })
  }

  def index[I, O, B, X, N](
      co: Entity[I, O, B, X])(
      f: B => N, g: B => X): IndexedEntity[I, O, B, X, N] = { xs =>

    def rm[A](as: List[A])(a: A): List[A] =
      as.zipWithIndex.filter(_._2 != as.indexOf(a)).map(_._1)

    val all = xs.map(x => (f(co(x).observe), x, co(x)))
    val obs = all.map(t => (t._1, t._3.observe)).toMap
    EntityF(obs, {
      case Attach(b) => (List(Attached(b)), Option(g(b._2) :: xs))
      case Detach(n) => {
        all.find(_._1 == n)
          .map(_._2)
          .fold((List[IndexOut[O, B, N]](UnknownIndex(n)), Option(xs))) { x =>
            (List(Detached(n)), Option(rm(xs)(x)))
          }
      }
      case WrapIn((n, i)) => {
        all.find(_._1 == n).fold(
          (List[IndexOut[O, B, N]](UnknownIndex(n)), Option(xs))) {
            case (n, x, e) => {
              val (os, ox) = e.next(i)
              val m = xs.indexOf(x)
              (os.map(o => WrapOut((n, o))), Option(ox.fold(
                rm(xs)(x))(xs.updated(m, _))))
            }
          }
      }
    })
  }

  def coexist[I1, I2, I, O1, O2, O, B1, B2, B, X1, X2, X](
      co1: Entity[I1, O1, B1, X1],
      co2: Entity[I2, O2, B2, X2])(implicit
      ev0: ClearSum.Aux[I1, I2, I],
      ev1: ClearSum.Aux[O1, O2, O],
      ev2: ClearProduct.Aux[B1, B2, B],
      ev3: ClearProduct.Aux[X1, X2, X]): Entity[I, O, B, X] = { x =>
    val (s, t) = (ev3.piA(x), ev3.piB(x))
    val EntityF(obs1, nxt1) = co1(s)
    val EntityF(obs2, nxt2) = co2(t)
    EntityF(ev2(obs1, obs2), i => ev0(
      i1 => nxt1(i1).bimap(_.map(o => ev1(o.left)), _.map(ev3(_, t))),
      i2 => nxt2(i2).bimap(_.map(o => ev1(o.right)), _.map(ev3(s, _))), i))
  }

  // Permits two coalgebras to share the very same inner state.
  def fusion[I1, I2, I, O1, O2, O, B1, B2, B, X](
      co1: Entity[I1, O1, B1, X],
      co2: Entity[I2, O2, B2, X])(implicit
      ev0: ClearSum.Aux[I1, I2, I],
      ev1: ClearSum.Aux[O1, O2, O],
      ev2: ClearProduct.Aux[B1, B2, B]): Entity[I, O, B, X] = { x =>
    val EntityF(obs1, nxt1) = co1(x)
    val EntityF(obs2, nxt2) = co2(x)
    EntityF(ev2(obs1, obs2), i => ev0(
      i1 => nxt1(i1).swap.map(os => os.map(o1 => ev1(o1.left))).swap,
      i2 => nxt2(i2).swap.map(os => os.map(o2 => ev1(o2.right))).swap,
      i))
  }

  def flow[A, I, O, B, B1, B2, X, X1, X2](
      co1: Entity[I, A, B1, X1],
      co2: Entity[A, O, B2, X2])(implicit
      ev0: ClearProduct.Aux[B1, B2, B],
      ev1: ClearProduct.Aux[X1, X2, X]): Entity[I, O, B, X] = { x =>
    val EntityF(obs1, nxt1) = co1(ev1.piA(x))
    val x2 = ev1.piB(x)
    val EntityF(obs2, _) = co2(x2)
    EntityF(ev0(obs1, obs2), { i1 =>
      val (o1s, ox1) = nxt1(i1)
      val (o2s, ox2) = feed(co2, o1s, x2)
      (o2s, (ox1 |@| ox2)(ev1(_, _)))
    })
  }
}

trait EntityWrapDsl {
  implicit class WrapHelper[N, I](i: (N, I)) {
    def wrap: WrapIn[I, N] = WrapIn(i)
  }
}

trait EntityNextDsl {

  implicit class Result[O, X](v: (List[O], Option[X])) {
    def ~>(os: O*): (List[O], Option[X]) =
      v.swap.map(_ ++ os.toList).swap
  }

  def skip[O, X](implicit x: X): (List[O], Option[X]) =
    (List.empty, Option(x))

  def warn[O, X](os: O*)(implicit x: X): (List[O], Option[X]) =
    (os.toList, Option(x))

  implicit def fresh[O, X](x: X): (List[O], Option[X]) =
    (List.empty, Option(x))

  implicit def freshR[O, X](x: X): Result[O, X] = Result(fresh(x))

  def halt[O, X]: (List[O], Option[X]) =
    (List.empty, Option.empty)
}
